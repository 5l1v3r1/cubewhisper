// Command reconstructgen generates samples for the
// recorder in https://github.com/unixpickle/speechrecog
// by reading through a solve data file generated by
// https://github.com/unixpickle/humancube.
package main

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"math/rand"
	"os"
	"strings"
	"time"
)

type ReconstructedSolve struct {
	Reconstruction string
}

const (
	MinLen        = 1
	MaxLen        = 30
	MaxFieldCount = 15000
)

func main() {
	rand.Seed(time.Now().UnixNano())
	if len(os.Args) != 2 {
		fmt.Fprintln(os.Stderr, "Usage: samplegen <solves.json>")
		os.Exit(1)
	}
	fileContents, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		fmt.Fprintln(os.Stderr, "Failed to read file:", err)
		os.Exit(1)
	}
	var reconstructions []ReconstructedSolve
	if err := json.Unmarshal(fileContents, &reconstructions); err != nil {
		fmt.Fprintln(os.Stderr, "Failed to unmarshal data:", err)
		os.Exit(1)
	}

	var allFields []string
	p := rand.Perm(len(reconstructions))
	for _, i := range p {
		rec := reconstructions[i].Reconstruction
		allFields = append(allFields, strings.Fields(rec)...)
	}

	if len(allFields) > MaxFieldCount {
		allFields = allFields[:MaxFieldCount]
	}

	fmt.Println("{\"Samples\": [")
	var i int
	for i < len(allFields) {
		takeLen := rand.Intn(MaxLen-MinLen+1) + MinLen
		if takeLen > len(allFields)-i {
			takeLen = len(allFields) - i
		}
		label := strings.Join(allFields[i:i+takeLen], " ")
		i += takeLen
		if strings.Contains(label, "3") {
			continue
		}
		fmt.Printf("  {\"Label\": \"%s\", \"File\":\"\", \"ID\": \"%s\"}",
			label, randomID())
		if i < len(allFields) {
			fmt.Println(",")
		} else {
			fmt.Println("]")
		}
	}
	fmt.Println("}")
}

func randomID() string {
	var buf [16]byte
	for i := 0; i < len(buf); i++ {
		buf[i] = byte(rand.Intn(0x100))
	}
	return strings.ToLower(hex.EncodeToString(buf[:]))
}
